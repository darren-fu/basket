# Redis 集群
- 自动把数据切分到多个Redis节点中
- 当一部分节点挂了或不可达，集群依然能继续工作
  - 所有master参与选举，半数以上master节点与故障节点通信超时将触发故障转移
  - 任意master挂掉且该master没有slave节点，集群将进入fail状态。如果master有slave节点，但是有半数以上master挂掉，集群也将进入fail状态
  - 当集群fail时，所有对集群的操作都不可用，会受到clusterdown the cluster is down的错误
- 两个端口
  - 客户端端口（一般是6379）需要对所有客户端和集群节点开放，因为集群节点需要通过该端口转移数据。
  - 集群总线端口（一般是16379）只需对集群中的所有节点开放，各节点通过集群总线检测宕机节点、更新配置、故障转移验证等，使用的协议不同于客户端的协议，是二进制协议
- Redis集群不是使用一致性哈希，而是使用哈希槽。整个Redis集群有16384个哈希槽，决定一个key应该分配到那个槽的算法是：计算该key的CRC16结果再模16834。
- 集群使用了主从模型，每个哈希槽有一（主节点）到N个副本（N-1个从节点）
  - 有A,B,C三个节点，如果B节点故障集群就不能正常工作
  - A,B,C三个节点是主节点，A1, B1, C1 分别是他们的从节点，当B节点宕机时，我们的集群也能正常运作。B1节点是B节点的副本，如果B节点故障，集群会提升B1为主节点，从而让集群继续正常工作。但是，如果B和B1同时故障，集群就不能继续工作了
  
 - Redis集群不能保证强一致性。一些已经向客户端确认写成功的操作，会在某些不确定的情况下丢失。因为主从节点之间使用了异步的方式来同步数据
 
## Redis集群参数配置
- cluster-enabled <yes/no>: 如果配置”yes”则开启集群功能，此redis实例作为集群的一个节点，否则，它是一个普通的单一的redis实例。
- cluster-config-file <filename>: 注意：虽然此配置的名字叫“集群配置文件”，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。
- cluster-node-timeout <milliseconds>: 这是集群中的节点能够失联的最大时间，超过这个时间，该节点就会被认为故障。如果主节点超过这个时间还是不可达，则用它的从节点将启动故障迁移，升级成主节点。注意，任何一个节点在这个时间之内如果还是没有连上大部分的主节点，则此节点将停止接收任何请求。
- cluster-slave-validity-factor <factor>: 如果设置成０，则无论从节点与主节点失联多久，从节点都会尝试升级成主节点。如果设置成正数，则cluster-node-timeout乘以cluster-slave-validity-factor得到的时间，是从节点与主节点失联后，此从节点数据有效的最长时间，超过这个时间，从节点不会启动故障迁移。假设cluster-node-timeout=5，cluster-slave-validity-factor=10，则如果从节点跟主节点失联超过50秒，此从节点不能成为主节点。注意，如果此参数配置为非0，将可能出现由于某主节点失联却没有从节点能顶上的情况，从而导致集群不能正常工作，在这种情况下，只有等到原来的主节点重新回归到集群，集群才恢复运作。
- cluster-migration-barrier <count>:aster需要保留的slaves的最少个数；如果一个master拥有比此值更多的slaves，那么Cluster将会使用“migration”机制，将多余的slaves迁移到其他master上，这些master持有的slaves的数量低于此值。最终Cluster希望做到，slaves能够按需迁移，在failover期间，确保每个master都有一定量的slaves，以提高集群整体的可用性。（比如A有三个slaves：A1、A2、A3，而B只有一个slave B1，当B失效后，B1提升为master，但是B1没有任何slave，所以存在风险，那么migration机制，可以将A下的某个slave迁移到B1下，成为B1的slave。
- cluster-require-full-coverage <yes/no>:“集群是否需要全量覆盖”，集群全部的slot有节点负责，如果设置为yes（默认值），当集群中有slots没有被任何node覆盖（通常是由于某个master失效，但是它也没有slave接管时），集群将会终止接收writes请求；如果设置为no，集群中那些服务正常的nodes（slots）仍然可以继续服务


## 节点超时
比如６个节点，A,B,C是主节点，A1,B1,C1分别是他们的从节点，一个客户端称之为Z1

当网络出问题时，他们被分成２组网络，组内网络联通，但２组之间的网络不通，假设A,C,A1,B1,C1彼此之间是联通的，另一边，B和Z1的网络是联通的。
Z1可以继续往B发起写操作，Ｂ也接受Z1的写操作。当网络恢复时，如果这个时间间隔足够短，集群仍然能继续正常工作。
如果时间比较长，以致B1在大多数的这边被选为主节点，那刚才Z1发给Ｂ的写操作都将丢失。

注意，Z1给Ｂ发送写操作是有一个限制的，如果时间长度达到了大多数节点那边可以选出一个新的主节点时，少数这边的所有主节点都不接受写操作。

这个时间的配置，称之为**节点超时**（node timeout），对集群来说非常重要，当达到了这个节点超时的时间之后，主节点被认为已经宕机，可以用它的一个从节点来代替。同样，在节点超时时，如果主节点依然不能联系到其他主节点，它将进入错误状态，不再接受写操作。

## 故障检测
- 集群中的每个节点都会定期的向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为疑似下线（probable fail，PFAIL）。 
- 集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，例如某个节点是处于在线状态、疑似下线状态（PFAIL），还是已下线状态（FAIL）。 
- 如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点X报告为疑似下线，那么这个主节点X将被标记为已下线（FAIL），将主节点X标记为已下线的节点会向集群广播一条关于主节点X的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点X标记为已下线。

## 故障转移
当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移执行的步骤： 
1. 复制下线主节点的所有从节点里面，会有一个从节点被选中； 
2. 被选中的从节点会执行SLAVEOF no one命令，成为新的主节点； 
3. 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己； 
4. 新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。 
5. 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。
 
